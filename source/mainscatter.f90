MODULE inputvariables
IMPLICIT NONE
SAVE

! Declare double precision
INTEGER, PARAMETER :: DBL = SELECTED_REAL_KIND(p=13,r=200)

! Maximum number of quadrature points per element
INTEGER, PARAMETER :: MAXN = 500

! Static parameters
REAL(KIND=DBL), PARAMETER :: PI = 3.141592653589
REAL(KIND=DBL), PARAMETER ::TOLERANCE = 1D-10
REAL(KIND=DBL), PARAMETER :: duey=2.0d0
COMPLEX(KIND=DBL), PARAMETER :: czero=(0.0D0,0.0D0)
COMPLEX(KIND=DBL), PARAMETER :: cone=(1.0D0,0.0D0)
COMPLEX(KIND=DBL), PARAMETER :: cimag=(0.0D0,1.0D0)

! Quadrature gobals
INTEGER :: numelements, celements, relements
INTEGER :: norder, angular

! DVR gobals
INTEGER :: nbasis
REAL(KIND=DBL) :: gridend
COMPLEX(KIND=DBL) :: contourphase

! Insertion gobals
INTEGER :: numgauss, numprimg

! Calculation choices
INTEGER ::switchv, kedvr
INTEGER :: l_ang, m_ang
INTEGER :: partitionflag
REAL(KIND=DBL) :: SVD_tol
REAL(KIND=DBL) :: contourpt
REAL(KIND=DBL) :: angle
REAL(KIND=DBL) :: mass=1.0
REAL(KIND=DBL) :: outstep
END MODULE



PROGRAM mainscatter
USE inputvariables
IMPLICIT NONE

! Local variables
INTEGER :: i, info

! Hamiltonian matrices
COMPLEX(KIND=DBL), ALLOCATABLE :: kinetic(:,:), potential(:,:), temppot1(:,:), temppot2(:,:)

! Basis information
COMPLEX(KIND=DBL), ALLOCATABLE :: gridpts(:)
COMPLEX(KIND=DBL), ALLOCATABLE :: gridweights(:)

! Wavefunction test of properites of the ground state
INTEGER :: wfn
COMPLEX(KIND=DBL), ALLOCATABLE :: wavefunction(:)

! Partition variables
REAL(KIND=DBL) :: escale
REAL(KIND=DBL) :: offset
REAL(KIND=DBL) :: expon
REAL(KIND=DBL) :: partition


!The order of operations
!Read in from file
OPEN(UNIT=1000, FILE='scattering.inp', STATUS='old', ACTION='READ')

READ(1000,*) numelements, norder
READ(1000,*) l_ang, m_ang
READ(1000,*) angle, celements
READ(1000,*) numgauss, numprimg
READ(1000,*) kedvr, switchv
READ(1000,*) partitionflag
READ(1000,*) SVD_tol
READ(1000,*) wfn

CLOSE(1000)

! Calculate some constants
relements = numelements-celements
nbasis = (norder-1)*numelements-1
contourphase = DCMPLX(COS(angle*PI/180.),SIN(angle*PI/180.))

! Check input parameters
CALL calcheck(info)
IF(info /= 0) THEN
   WRITE(*,'(" Calculation check failed.  info = ", I3)') info
   STOP
ENDIF

! Generate the DVR grid, the weights and the KE matrix
ALLOCATE(gridpts(1:nbasis), gridweights(1:nbasis))
ALLOCATE(kinetic(1:nbasis,1:nbasis))
gridpts = czero
gridweights = czero
kinetic = czero

CALL dvr(numelements, celements, norder, nbasis, angle, gridpts, gridweights, kinetic)

! Test projector, should return eigenvalues of 1 or 0.
! CALL projection(gridpts, gridweights)

! Should the KE matrix be generated by insertion? (switchv=2)
IF(kedvr .EQ. 1) THEN
   CALL kenginsert(kinetic, gridpts, gridweights)
ENDIF

!Generate the potential either on DVRs (switchv=0) or via insertion (switchv.NE.1)
ALLOCATE(potential(1:nbasis,1:nbasis))
potential = czero

IF(switchv .EQ. 0) THEN
   DO i=1,nbasis
      potential(i,i) = -1.0/gridpts(i) +0.5d0*(l_ang*(l_ang+1.0d0))/gridpts(i)/gridpts(i)
   ENDDO
   
ELSEIF(switchv .EQ. 1) THEN
   IF(partitionflag .EQ. 0) THEN
      potential = czero
      WRITE(*,*) "SVD time!"
      CALL potential_insert(potential, gridpts, gridweights, 1)

      IF (l_ang > 0) THEN
         DO i=1, nbasis
            potential(i,i) = potential(i,i) + 0.5d0*(l_ang*(l_ang+1.0d0))/gridpts(i)/gridpts(i)
         ENDDO
      ENDIF

   ELSE
      potential = czero
      WRITE(*,*) "Partitioning!"
      ALLOCATE(temppot1(1:nbasis,1:nbasis),temppot2(1:nbasis,1:nbasis))
      CALL potential_insert(temppot1, gridpts, gridweights, 0)

      CALL potential_insert(temppot2, gridpts, gridweights, -1)

      DO i=1, norder-1
         potential(i,i) = -10.0/gridpts(i)
      ENDDO

      escale = gridpts(2*norder-2) - gridpts(norder-1)
      offset = gridpts(norder-1) + escale

      DO i=norder, 2*norder-2
         expon = ((gridpts(i)-offset)/escale)
         partition = EXP(expon*expon/(expon*expon-1))
         potential(i,i) = -10.0*(1.0d0-partition)/gridpts(i)
      ENDDO

      potential = potential + temppot1 + temppot2

      IF (l_ang > 0) THEN
         DO i=1, nbasis
            potential(i,i) = potential(i,i) + 0.5d0*(l_ang*(l_ang+1.0d0))/gridpts(i)/gridpts(i)
         ENDDO
      ENDIF
   ENDIF
ENDIF

!Calculates the energy spectrum
WRITE(*,*) " Calcuation ENERGY!"

ALLOCATE(wavefunction(1:nbasis))
CALL engspec(kinetic, potential, wavefunction, wfn)

!!$! Test properties of the eigenvalues and eigenvectors
!!$CALL eigentest(kinetic, potential,gridpts,gridweights, wavefunction)


DEALLOCATE(gridpts, kinetic)
DEALLOCATE(gridweights)
DEALLOCATE(potential)
DEALLOCATE(wavefunction)
ENDPROGRAM
